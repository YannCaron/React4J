# Welcome

Welcome to **React4J**. This library aim to introduce Functional Reactive Programming in Java programming language.
It was inspired by Scala.react library currently developed by [Ingo Maier](https://github.com/ingoem) and [Martin Odersky](http://fr.wikipedia.org/wiki/Martin_Odersky) see https://github.com/ingoem/scala-react.
Some behaviors have been patterned after Haskell ans ELM functional reactive programming capabilities : [FRP in Haskell](http://www.haskell.org/haskellwiki/Functional_Reactive_Programming) and [ELM programming language](http://elm-lang.org/learn/What-is-FRP.elm)

For more details about reactive programming and its benefits in comparison to Observer design pattern, see Deprecating the Observer Pattern with **Scala.React** : http://infoscience.epfl.ch/record/176887/files/DeprecatingObservers2012.pdf

## More details ##
**React4J** fits in the discrete reactive frameworks familly e.g. it is event based.

There is two way to design an FRP framework :
* by * **Continuous** reactions, a centralized manager maintains all reactives signals that are periodically actualized. It is an old and cpu consumer way because unnecessary values are computed in a sample time.

* by **Discrete** reactions that are event driver. The values are only updates if an event that change their value has been emiter.

*React4J go further* than this rule, a value is updated if an event is emit and something is subscribed to it. Everything else is igored.

Like other FRP frameworks, *React4J* works with two entities : States (can be a variable or an operation between variables) that represent a value that evolve in time. *Var* and *Operations* have an initial state. And the Signals that represents single events emited by a device (or by timers). *Signal* does not have value until the event is raised.

## Value centrered ##
This is an example of value centered reaction in **React4J** :


```
#!java

final Var<Integer> a = new Var<Integer>(1);
final Var<Integer> b = new Var<Integer>(2);
final VarReact<Integer> sum = new VarReact<Integer>(new Function<Integer>() {

	@Override
	public Integer invoke() {
		return a.getValue() + b.getValue();
	}
}, a, b);

sum.map(new Function1<String, Integer> () {

	@Override
	public String invoke(Integer value) {
		return "sum result = " + value;
	}
}).subscribe(new Procedure1<String>() {

	@Override
	public void invoke(String value) {
		System.out.println(value);
	}
});

a.setValue(5);
// raise calculation of sum :
// sum result = 7

b.setValue(7);
// raise calculation of sum :
// sum result = 12
```

In this example a, b and sum are some descrete reacts. If a or b are changed sum is automatically modified and an event is raised. It is possible to subscribe to any react of the program and to create any combination of react you want. Events will be propagated into the obtained calculus tree.

## Continuous reaction ##
Before describe any reaction, this is how to create Reactive JLabel with Swing.
Node: This principle can be applied to any other user interface library.
```
#!java
public class RLabel extends JLabel {

	public void setText(Signal<String> text) {
		text.subscribe(new Procedure1<String>() {

			@Override
			public void invoke(String value) {
				setText(value);
			}
		});
		setText(text.getValue());
	}

}
```
To create reactive JLabel, the new RLabel class must inherits from JLabel and define an overriding setText method. This method accept a Signal as input argument, subscribe to it : each time the react emit, the label text value will be changed.

Now imagine we want to catch mouse event as following :
We want to update the RLabel with mouse click event and its position.
The RLabel must be updated every time the button is clicked and every time the mouse is moved.

```
#!java
Signal<String> mouseAndTime = MouseReact.hold(1).map(new Function1<String, MouseEvent>() {

	@Override
	public String invoke(MouseEvent value) {
		// when mouse button is pressed
		return "button pressed";
	}
}).otherwise(new Function1<String, String>() {

	@Override
	public String invoke(String arg1) {
		// when it is released
		return "button released";
	}
}).merge(MouseReact.move()).map(new Function1<String, Tuple<String, MouseEvent>>() {

	@Override
	public String invoke(Tuple<String, MouseEvent> values) {
		// concatenate with mouse move event position
		return values.getFirst() + " at (x= " + values.getSecond().getX() + ", y= " + values.getSecond().getY() + ")";
	}
});

label1.setText(mouseAndTime);
```

That's it, with a small handful of lines of code ! In fact, only one line, method call are chained !
With java 8 and closures, this code will be drastically reduced.

This is our reactive RLabel in action (updated on each mouse event) :

![RLabel and merged mouse react](https://bitbucket.org/yann_caron/react4j/downloads/Demo1.png)

## Demo ##
FRP will bring a great innovation in the GUI frameworks as well as in the field of video games development !

Try react4j animation demo : [Download demo jar](https://bitbucket.org/yann_caron/react4j/downloads/ReactDemo-release.jar)

Launch it with : `java -jar ReactDemo-release.jar`

This demo demonstrate the react4j capabilities in the field of graphical interactions. The circles are animated by a merging of mouse and time reacts. Each object has it own reactions, programmer have to subscribe to it. Just a couple of lines of code are necessary to create great behaviors.

![Live demo](https://bitbucket.org/yann_caron/react4j/downloads/Demo2.png)

Youtube : [Youtube live demo](https://www.youtube.com/watch?v=0VGU9qcjnbM)

Have fun!