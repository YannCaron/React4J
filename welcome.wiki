# Welcome

Welcome to **React4J**. This library aim to introduce Functional Reactive Programming in Java programming language.

Functional Reactive Programming (FRP) is a high-level functional architecture that aims to work with interactions and time. It provides control flow structures for time. FRP consider states as time-varying values.

It was inspired by Scala.react library currently developed by [Ingo Maier](https://github.com/ingoem) and [Martin Odersky](http://fr.wikipedia.org/wiki/Martin_Odersky) see https://github.com/ingoem/scala-react.
Some behaviors have been patterned after Haskell and ELM functional reactive programming capabilities : [FRP in Haskell](http://www.haskell.org/haskellwiki/Functional_Reactive_Programming) and [ELM programming language](http://elm-lang.org/learn/What-is-FRP.elm)

For more details about reactive programming and its benefits in comparison to Observer design pattern, see [Deprecating the Observer Pattern](http://infoscience.epfl.ch/record/176887/files/DeprecatingObservers2012.pdf) with **Scala.React**

## More details ##
**React4J** fits in the discrete reactive frameworks familly e.g. it is event based.

There is two way to design an FRP framework :

* by * **Continuous** reactions, a centralized manager maintains all reactives signals that are periodically actualized. It is an old and cpu consumer way because unnecessary values are computed in a sample time.

* by **Discrete** reactions that are event driver. The values are only updates if an event that change their value has been emiter.

*React4J go further* than this rule, a value is updated if an event is emit and something is subscribed to it. Everything else is igored, time is suspended and events are inactive.

Like other FRP frameworks, **React4J** works with two entities : States (can be a variable or an operation between variables) that represent a value that evolve in time. **Var** and **Operation** objects have an initial state. And the behaviours that are resulting of single events emited by a device (or by timers). **Signal** objects does not have value until the event is raised.

## Value centrered (**Var** and **Operation**)##
This is an example of value centered reaction in **React4J** :


```
#!java

final Var<Integer> a = new Var<Integer>(1);
final Var<Integer> b = new Var<Integer>(1);

Operation<Integer> sum = Operation.syncOperation(new Function<Integer>() {

	@Override
	public Integer invoke() {
		return a.getValue() + b.getValue();
	}
}, a, b);

sum.map(new Function1<String, Integer>() {

	@Override
	public String invoke(Integer value) {
		return "Sum result= " + value;
	}
}).subscribe(new Procedure1<String>() {

	@Override
	public void invoke(String value) {
		System.out.println(value);
	}
});

a.setValue(1);
// nothing appends

a.setValue(2);
// nothing appends

b.setValue(8);
// raise event
// Sum result= 10 e.g. 2 + 8

b.setValue(7);
// nothing appends

a.setValue(4);
// nothing appends
// Sum result= 1 e.g. 4 + 7

```

In this example a, b and sum are some state centered reacts. If a and b are changed sum value is automatically updated and an event is raised.

Operations can work in two modes : merge and sync
* **merge**: emit if any operande is updated. Consider merge mode like an "or" operation : event is raised if *a* **or** *b* are changed. 
* **sync**: emit each time the two operandes are updates. Keep only the last value of each operands. Consider sync mode like an "and" operation : event is raise of *a* **and** *b* are changed together.

Naturally, it is possible to subscribe to any react of the program and to create as any combination of operation as needed. Events will be propagated into the obtained calculus binary tree. This behaviour binary tree is the resulting of combination of the differents operation modes.

## Behaviour centered (**Signal**) ##
Functional reactive programming finds its application in user interactions domains like HMI or video game developpment.

Before describe any reaction, let's create an HMI JLabel component with **Swing**.
Node: This principle can be applied to any other user interface library.
```
#!java
public class RLabel extends JLabel {

	public void setText(Var<String> text) {
		text.subscribe(new Procedure1<String>() {

			@Override
			public void invoke(String value) {
				setText(value);
			}
		});
		setText(text.getValue());
	}

}
```
To create reactive JLabel, the new RLabel class must inherits from JLabel and define an overriding setText method. This method accept a Signal as input argument, subscribe to it : each time the react emit, the label text value will be changed.

Now imagine we want to update automatically our JLabel with the mouse click event and its position.
The RLabel must be updated every time the button is clicked and every time the mouse is moved.

```
#!java
// when mouse is pressed say "pressed" otherwise say "released"
// concatenate message with mouse position and update each time it is necessary

// declare the mouse reactor
Var<String> mouseAndTime = MouseReact.hold().filter(MouseReact.BUTTON1).map(new Function1<String, Integer>() {

	@Override
	public String invoke(Integer value) {
		// when mouse button is pressed
		return "button pressed";
	}
}).otherwise(new Function1<String, String>() {

	@Override
	public String invoke(String arg1) {
		// when it is released
		return "button released";
	}
}).toVar("no button yet !").merge(mouseX, new Function2<String, String, Integer>() {

	@Override
	public String invoke(String arg1, Integer arg2) {
		// add mouse x position
		return arg1 + " ( x=" + arg2;
	}
}).merge(mouseY, new Function2<String, String, Integer>() {

	@Override
	public String invoke(String arg1, Integer arg2) {
		// add mouse y position
		return arg1 + ", y=" + arg2 + ")";
	}
});

label1.setText(mouseAndTime);
```

This is our reactive RLabel in action (updated on each mouse event) :

![RLabel and merged mouse react](https://bitbucket.org/yann_caron/react4j/downloads/Demo1.png)

That's it, with a small handful of lines of code ! In fact, only one line, method call are chained !
With **java 8** and **closures**, this code will be drastically reduced. When [Issue#9](https://bitbucket.org/yann_caron/react4j/issue/9/jdk8-lambda-ready) will be resolved, **React4J** will be ready to accept Java 8 closures.

## Demo ##
FRP will bring a great innovation in the GUI frameworks as well as in the field of video games development ! **I am actually minding about robotic applications of FRP to describe the Robot behaviours in case of its sensors events.**

Try react4j animation demo : [Download demo jar](https://bitbucket.org/yann_caron/react4j/downloads/React4J.jar)

Launch it with : `java -jar React4J.jar`

This demo demonstrate the react4j capabilities in the field of graphical interactions. Just a couple of lines of code are necessary to create great behaviors.

![Live demo](https://bitbucket.org/yann_caron/react4j/downloads/Demo2.png)

Youtube : [Youtube live demo](https://www.youtube.com/watch?v=0VGU9qcjnbM)

Have fun!